Dicexp {
  Exp = BinOpExpP10

  // binary operators
  // P<x> == Precedence <x>
  // P<x>p<y> == Precedence <x>.<y>
  // Pn<x> == Precedence negative <x>
  BinOpExpP10
    = BinOpExpP10 "||" BinOpExpP11  -- or
    | BinOpExpP11
  BinOpExpP11
    = BinOpExpP11 "&&" BinOpExpP20  -- and
    | BinOpExpP20
  BinOpExpP20
    = BinOpExpP20 "==" BinOpExpP21  -- eq
    | BinOpExpP20 "!=" BinOpExpP21  -- not_eq
    | BinOpExpP21
  BinOpExpP21
    = BinOpExpP21 "<" BinOpExpP30  -- lt
    | BinOpExpP21 ">" BinOpExpP30  -- gt
    | BinOpExpP21 "<=" BinOpExpP30 -- lte
    | BinOpExpP21 ">=" BinOpExpP30 -- gte
    | BinOpExpP30
  BinOpExpP30
    = BinOpExpP30 "|>" BinOpExpP40  -- pipe
    | BinOpExpP40
  BinOpExpP40
    = BinOpExpP40 "#" BinOpExpP50 -- repeat
    | BinOpExpP50
  BinOpExpP50
    = BinOpExpP50 "~" UnOpExpP51 -- range
    | UnOpExpP51
  UnOpExpP51
    = "~" BinOpExpP60 -- range
    | BinOpExpP60
  BinOpExpP60
    = BinOpExpP60 "+" UnOpExpP61  -- add
    | BinOpExpP60 "-" UnOpExpP61  -- sub
    | UnOpExpP61
  UnOpExpP61
    = "+" BinOpExpP62 -- noop
    | "-" BinOpExpP62 -- negate
    | BinOpExpP62
  BinOpExpP62
    = BinOpExpP62 "*" BinOpExpP70   -- mul
    | BinOpExpP62 "//" BinOpExpP70  -- div_int
    | BinOpExpP62 "%" BinOpExpP70   -- mod_non_negative_int
    | BinOpExpP70
  BinOpExpP70
    = RollGrouping "d" RollGrouping   -- roll
    | RollGrouping "d%" RollGrouping  -- roll_dao
    | UnOpExpP71
  UnOpExpP71
    = "d" BinOpExpP80 -- roll
    | "d%" BinOpExpP80 -- roll_dao
    | BinOpExpP80
  BinOpExpP80
    = BinOpExpP80 "^" UnOpExpP100 -- exponent
    | UnOpExpP100
  
  // unary operators
  UnOpExpP100
    = "~" UnOpExpP100 -- range
    | "+" UnOpExpP100 -- noop
    | "-" UnOpExpP100 -- negate
    | "d" RollGrouping  -- roll
    | "d%" RollGrouping -- roll_dao
    // 虽然没搞清楚原理，
    // 但是上下重复定义两遍就能在保证优先级正确的情况下还解析 `1 ~ -10` 这样的代码

    | "!" UnOpExpP100 -- not
    | BinOpCall

  BinOpCall 
    = BinOpCall "." ArgumentList -- call
    | GroupingExp

  RollGrouping
    = "(" Exp ")" -- grouping
    | literalInteger
  
  GroupingExp
    = "(" Exp ")" -- grouping
    | CallExp
    | ListExp
    | ClosureExp
    | capture
    | literal
    | ident

  CallExp
    = functionIdent ArgumentList  -- regular
    | functionIdent ClosureExp    -- closure_argument_short

  ArgumentList = "(" ListOf<Exp, ","> ")"
  
  ListExp = "[" ListOf<Exp, ","> "]"
  
  ClosureExp = "\\(" ListOf<ident, ","> "->" Exp ")"

  capture
    = "&" ident "/" literalInteger
    | "&" unarySymbol "/" "1"
    | "&" binarySymbol "/" "2"

  unarySymbol = "-" | "!" | "~" | "d" | "d%"
  binarySymbol
    = "||" | "&&" | "==" | "!=" | "<" | ">" | "<=" | ">="
    // | "|>" | "#" // 这两个运算符比较特别，会改变代码结构，因此不允许被捕获
    | "~" | "+" | "-" | "*" | "//" | "%"
    | "d" | "d%"
    | "^"

  functionIdent = ident "!"?

  ident
    = identHead identRestChar*
  identHead
    = "_" | letter
  identRestChar
    = identHead | digit
  
  literal
    = literalInteger | literalBoolean
  literalInteger
    = digit ("_" | digit) *
  literalBoolean
    = "true" | "false"
 
}
