Dicexp {
  Exp = BinOpExpPn4

  // binary operators
  // P<x> == Precedence <x>
  // P<x>p<y> == Precedence <x>.<y>
  // Pn<x> == Precedence negative <x>
  BinOpExpPn4
    = BinOpExpPn4 "||" BinOpExpPn3  -- or
    | BinOpExpPn3
  BinOpExpPn3
    = BinOpExpPn3 "&&" BinOpExpPn2  -- and
    | BinOpExpPn2
  BinOpExpPn2
    = BinOpExpPn2 "==" BinOpExpPn1  -- eq
    | BinOpExpPn2 "!=" BinOpExpPn1  -- not_eq
    | BinOpExpPn1
  BinOpExpPn1
    = BinOpExpPn1 "<" BinOpExpP0  -- lt
    | BinOpExpPn1 ">" BinOpExpP0  -- gt
    | BinOpExpPn1 "<=" BinOpExpP0 -- lte
    | BinOpExpPn1 ">=" BinOpExpP0 -- gte
    | BinOpExpP0
  BinOpExpP0
    = BinOpExpP0 "|>" BinOpExpP0p1  -- pipe
    | BinOpExpP0p1
  BinOpExpP0p1
    = BinOpExpP0p1 "#" BinOpExpP1 -- repeat
    | BinOpExpP1
  BinOpExpP1
    = BinOpExpP1 "~" UnOpExpP1 -- range
    | UnOpExpP1
  UnOpExpP1
    = "~" BinOpExpP2 -- range
    | BinOpExpP2
  BinOpExpP2
    = BinOpExpP2 "+" UnOpExpP2  -- add
    | BinOpExpP2 "-" UnOpExpP2  -- sub
    | UnOpExpP2
  UnOpExpP2
    = "+" BinOpExpP3 -- noop
    | "-" BinOpExpP3 -- negate
    | BinOpExpP3
  BinOpExpP3
    = BinOpExpP3 "*" BinOpExpP4   -- mul
    | BinOpExpP3 "//" BinOpExpP4  -- div_int
    | BinOpExpP3 "%" BinOpExpP4   -- mod_non_negative_int
    | BinOpExpP4
  BinOpExpP4
    = BinOpExpP5 // FIXME: 什么时候把优先级位置挪一下
  BinOpExpP5
    = RollGrouping "d" RollGrouping   -- roll
    | RollGrouping "d%" RollGrouping  -- roll_dao
    | UnOpExpP5
  UnOpExpP5
    = "d" BinOpExpP6 -- roll
    | "d%" BinOpExpP6 -- roll_dao
    | BinOpExpP6
  BinOpExpP6
    = BinOpExpP6 "^" UnOpExpP10 -- exponent
    | UnOpExpP10
  
  // unary operators
  UnOpExpP10
    = "~" UnOpExpP10 -- range
    | "+" UnOpExpP10 -- noop
    | "-" UnOpExpP10 -- negate
    | "d" RollGrouping  -- roll
    | "d%" RollGrouping -- roll_dao
    // 虽然没搞清楚原理，
    // 但是上下重复定义两遍就能在保证优先级正确的情况下还解析 `1 ~ -10` 这样的代码

    | "!" UnOpExpP10 -- not
    | BinOpCall

  BinOpCall 
    = BinOpCall "." ArgumentList -- call
    | GroupingExp

  RollGrouping
    = "(" Exp ")" -- grouping
    | literalInteger
  
  GroupingExp
    = "(" Exp ")" -- grouping
    | CallExp
    | ListExp
    | ClosureExp
    | capture
    | literal
    | ident

  CallExp
    = functionIdent ArgumentList  -- regular
    | functionIdent ClosureExp    -- closure_argument_short

  ArgumentList = "(" ListOf<Exp, ","> ")"
  
  ListExp = "[" ListOf<Exp, ","> "]"
  
  ClosureExp = "\\(" ListOf<ident, ","> "->" Exp ")"

  capture
    = "&" ident "/" literalInteger
    | "&" unarySymbol "/" "1"
    | "&" binarySymbol "/" "2"

  unarySymbol = "-" | "!" | "~" | "d" | "d%"
  binarySymbol
    = "||" | "&&" | "==" | "!=" | "<" | ">" | "<=" | ">="
    // | "|>" | "#" // 这两个运算符比较特别，会改变代码结构，因此不允许被捕获
    | "~" | "+" | "-" | "*" | "//" | "%"
    | "d" | "d%"
    | "^"

  functionIdent = ident "!"?

  ident
    = identHead identRestChar*
  identHead
    = "_" | letter
  identRestChar
    = identHead | digit
  
  literal
    = literalInteger | literalBoolean
  literalInteger
    = digit ("_" | digit) *
  literalBoolean
    = "true" | "false"
 
}
