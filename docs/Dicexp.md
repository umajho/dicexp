# Dicexp

**Dicexp** 是一套用于 roll 点（掷骰）的表达式规则。

Dicexp 的语言风格在许多方面参考了 [Elixir](https://elixir-lang.org)。

_尚未在 `dicexp` 的执行器中实现的功能将使用斜体标示。_

## 快速上手

### 初级类型

- 整数，如 `42`、`-1`
- 值生成器（可以用来产生骰子结果），如：
  - `1~10`：随机生成 1 到 10 之间（含两侧）整数
  - `~10`：同上
  - `d10`：同上
  - `3d10`：生成三个上述整数，并求和
  - `d%10`：类似于 `d10`，但范围变为 0 到 9 之间[^1]

[^1]: 理论上是将结果与右侧的数求余，实际上是直接将结果减去 1。

### 整数运算

二元整数运算的优先级由高到低依次为：

- `^`（幂运算）
- `*`、`//`（整除）、`%`（非负数与正数相除求余）
- `+`、`-`

此外，`+`、`-` 也可以作为正负号，如：`-3*+5`。

### 值生成器运算符

像是 `~`、`d`、`d%` 这些被称作值生成器运算符。

优先级由高到低依次为：

- 整数运算 `^`
- `d`、`d%`
- 其他整数运算
- `~`

举例：`d5^2 // 4 ~ 6 + 3 * 4d6` 相当于 `((d(5^2)) // 4) ~ (6 + (3 * (4d6)))`。

### 关于全角符号

Dicexp 会自动将全角字符（如 “`！`”）转换成半角字符（如
“`!`”），因此无需关心半角、全角符号的问题。

### 进阶前瞻

以上这些功能足以满足绝大部分骰子表达式的使用场景。

有些较为常用的投掷需求需要用到进阶功能，这里提前列出：

- “投 4d6，其中每有 1 个出目大于等于 5 的骰子，则再投一个”：
  - _`explode(4d6, 5)`_
- “投 4d6，如果有骰子的出目小于等于 2，则重新投一遍”：
  - _`reroll(4d6, 2)`_

例：`1 + reroll(4d6, d2 + 1) + 3d10`。

## 进阶

### 高级类型

- 布尔值，如 `true`、`false`
- 列表，如 `[1, 2, 3]`
- _序列生成器_（用来产生列表，其成员由值生成器生成），如：
  - `3#d10`：一个序列，包含 3 个随机生成的 1 到 10 之间（含两侧）整数
  - `3$#3d10`：一个序列，包含 3 个整数，每个整数都是 3 个随机生成的 1 到 10
    之间（含两侧）整数的和
- 匿名函数，如：
  - `\(x, y -> x+y)`：取两个参数，并返回这两个参数的和
  - `\(-> true)`： 不取任何参数，返回 `true`
  - `\(_, _ -> true)`：取两个参数，无视这两个参数，返回 `true`
- 通常函数捕获（将通常的函数转为像是匿名函数一样的值），如：
  - `&-/1`（整数取相反数）
  - `&-/2`（整数相减）
  - `&sum/1`（列表求和）

### 比较

以比较 a、b 为例，满足条件返回 `true`，不满足条件返回 `false`：

| 形式   | 判断             | 备注                                              |
| ------ | ---------------- | ------------------------------------------------- |
| `a==b` | a、b 是否相等    | 可以用于整数之间或布尔值之间，a、b 类型必须相同。 |
| `a!=b` | a、b 是否不等    | 可以用于整数之间或布尔值之间，a、b 类型必须相同。 |
| `a<b`  | a 是否小于 b     | 只可以用于整数之间。                              |
| `a>b`  | a 是否大于 b     | 只可以用于整数之间。                              |
| `a<=b` | a 是否小于等于 b | 只可以用于整数之间。                              |
| `a>=b` | a 是否大于等于 b | 只可以用于整数之间。                              |

### 布尔值

Dicexp 支持以下三种布尔运算：

- `||`（两个值之间的或运算），如：`false||true` 结果为 `true`。
- `&&`（两个值之间的与运算），如：`false&&true` 结果为 `false`。
- `!`（单个值自身的非运算），如：`!false` 结果为 `true`。

### 匿名函数

形如 `\(x, y -> x + y)`
的是匿名函数。以这个匿名函数为例，它接收两个参数，并在其内部按顺序赋予名字 `x`
与 `y`。

可以用 `<匿名函数>.(<参数列表>)` 的形式调用匿名函数，如：

- `\(x, y -> x + y).(1, 2)`，返回 `3`

如果匿名函数作为匿名函数的参数，有了名字，也需要如此调用：

- `\(f -> f.(1, 2)).(\(x, y -> x + y))`

如果在匿名函数中不需要用到某个参数，可以用_代替，且_可以重复多次：

- `\(_, b, _ -> b).(123, 456, 789)`，返回 `456`

### 内建函数

Dicexp 提供了许多内建函数，对于这类函数，一般习惯以 “`<函数名>/<参数数量>`”
来称呼。

例如，接受两个参数的 `sort` 函数叫 `sort/2`，接受三个参数的 `sort` 函数叫
`sort/3`。

大部分运算符（除了 `|>/2` 与 `#/2` 之外）也是内建函数。例如，`-/1`
是取相反数，`-/2` 则是两数相减。

与匿名函数不同，调用内建函数不用西文句号，而是参数列表紧接着函数名，如：

- `sum([1, 2, 3])`

#### 特殊内建函数

函数名以 `!`
结尾的函数比较特殊，不会像其他内建函数一样在调用时立刻对所有传入的参数求值，目前这样的函数仅有
`if!/3`。

此外，`|>/2`、`#/2` 也可以视作特殊内建函数。

#### 捕获内建函数

如果想把内建函数像匿名函数一样传递给其他函数，需要用到捕获。捕获方式为
`&<函数名>/<参数数量>`。

例如：

- 改变列表中数字的符号可以用：`map([123, -456, 789], &-/1)`
- 将两个列表的对应项相乘合并在一起可以用：`zipWith([1, 2, 3], [4, 5, 6], &*/2)`

特殊内建函数不能被捕获。

#### 匿名函数作为内建函数参数时的简写

如果内建函数的参数列表只有一个匿名函数，可以省略括号，如：

- `[2, 3, 5, 7, 11] |> filter \(x -> x >= 5)`

### 管道运算符

管道运算符 `|>` 可以将其左侧的值变为其右侧函数的第一个参数。

对于内建函数，例如 `at`，`at([1, 2, 3], 2)` 与 `[1, 2, 3] |> at(2)` 是一样的。

对于匿名函数，仍然需要西文句号：`1 |> \(x -> x+1).()`。

如果内建函数在使用管道运算符后参数列表为空，可以省略参数列表的括号：`[4, 5, 6] |> product`。

### 生成器

TODO

#### 值生成器

#### 序列生成器

## 内建函数一览

TODO

## 附录

### 运算符优先级表

由高到低依次为：

- `d/1`、`d%/1`、`d/2`、`d%/2`
- `!/1`
- `^/2`
- `*/2`、`///2`、`%/2`
- `+/1`、`-/1`
- `+/2`、`-/2`
- `~/1`
- `~/2`
- `#/2`
- `|>/2`
- `</2`、`>/2`、`<=/2`、`>=/2`
- `==/2`、`!=/2`
- `&&/2`
- `||/2`

为了确保可读行，`d/1`、`d%/1`、`d/2`、`d%/2`
不被允许直接连用。如需连用，要用括号确定优先级，如：`(d4)d4`、`3d(4d5)`。
